# 草稿——并发编程

- 由于cpu>内存>IO设备的读写速率差别，导致单方面提高cpu运算能力已经无法提升效率，根据木桶远离应该提高内存和IO设备的读写速率。而计算机组成结构、操作系统、程序编译都做出了优化：
    - 计算机组成结构：为cpu加入缓存，减少内存的读操作<font color=red>【疑问：是否更多的适用于读多写少的情况？】</font>
    - 操作系统：加入进程线程进行分时复用，更为合理地使用资源
    - 程序编译：实现优化指令执行顺序进而更加合理使用cpu缓存<font color=red>【疑问：为什么调整指令执行顺序能提升cpu缓存使用率？】</font>

- 并发编程Bug的源头
    - cpu缓存问题：多核计算机已普遍投入使用，而多个cpu也就意味着每个cpu都有自己缓存，在多线程操作过程中导致重复写的并发问题。
    - 线程切换：线程是操作系统层次的概念，操作系统通过线程切换实现并发编程，而对于线程来说单条指令才是原子操作，如Java中`count += 1;`这一行代码其实是由三条指令来完成的，过程如下：
        - 将变量count的值从内存中读取到cpu的寄存器
        - 在寄存器中对count执行+1操作
        - 将操作后的count写回内存
        
        若在count刚做完+1操作打算将count写回内存时发生线程进行切换，其他线程也对count进行数据变更，在操作之后切回原来的线程继续写回内存操作，那么就出现了重复加的并发问题。
    - 指令重排：由于CPU中一般都是基于流水线进行设计，为了提高效率会将无显式因果关系的指令分发到其余流水线进行执行，而这样会导致存在隐式因果关系的指令在重排后会使得结果与正常情况执行的结果不符。

- 并发编程领域可以抽象成三个核心问题：分工、同步和互斥。
    - 分工：将任务拆分后分配给线程
    - 同步：将数据操作的变更通知给其他线程
    - 互斥：临界资源某个时间段内只能由单个线程进行处理

- Happends-Before规则：前一个操作的结果对后面的操作是可见的。
    - 程序的顺序性规则
        
        在同一个线程中不会发生指令重排。
    - volatile规则
        
        对volatile修饰的变量的写操作的结果对读操作是可见的。
    - 传递性
        
        若A操作 `Happends-Before` B操作，且B操作 `Happends-Before` C操作，那么A操作 `Happends-Before` C操作。
    - 锁规则

        对一个锁的加锁操作 `Happends-Before` 锁的释放操作。

    - 线程start()规则

        主线程A启动子线程B后，子线程B对自身启动前的操作结果是已知的。

    - 线程join()规则

        主线程通过调用子线程join()方法来使主线程等待子线程结束后才继续执行，那么主线程对子线程完成执行前的操作结果对主线程都是可见的。

- 在Java中，解决线程协作问题的核心技术是管程。

- 导致可见行问题的原因是CPU缓存。

- 导致有序性问题的原因是编译优化。

- happens-before规则：前一个操作的结果对后面操作是可见的。
    - 程序的顺序性
    - volatile 变量规则
    - 传递性
    - 管程中锁的规则
    - 线程start()的规则
    - 线程join()的规则

- 原子性：原子性的外在表现是不可分割，本质是中间态不可见。

- 不可用可变对象作为锁对象。

- 死锁：一组相互竞争资源而互相等待导致一直阻塞的场景。
    - 互斥，共享资源 X 和 Y 只能被一个线程占用；
    - 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
    - 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
    - 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

- Java 语言内置的管程synchronized里只有一个条件变量，而 Lock&Condition 实现的管程是支持多个条件变量的。

- Semaphore 可以允许多个线程访问一个临界区。