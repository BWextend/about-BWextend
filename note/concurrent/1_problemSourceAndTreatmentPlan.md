# 并发编程问题来源

- [1.效率优化方案及问题](#1.效率优化方案及问题)
    - [1.1.计算机组成结构](#1.1.计算机组成结构)
    - [1.2.操作系统](#1.2.操作系统)
    - [1.3.程序编译](#1.3.程序编译)
- [2.Java并发问题解决方案](#2.Java并发问题解决方案)
    - [2.1.volatile](#2.1.volatile)
    - [2.2.final](#2.2.final)
    - [2.3.lock](#2.3.lock)
    - [2.4.Happend-Before原则](#2.4.Happend-Before原则)
- [3.参考资料](#3.参考资料)

> 由于cpu>内存>IO设备的读写速率差别，导致单方面提高cpu运算能力已经无法提升效率，根据木桶远离应该提高内存和IO设备的读写速率。而计算机组成结构、操作系统、程序编译都做出了优化，却也带来了可见性、原子性、有序性的问题。

## 1.效率优化方案及问题

### 1.1.计算机组成结构

- **优化点**：为cpu加入缓存，减少内存的读操作。<font color=red>【疑问：CPU缓存是否存在击穿问题？】</font>
- **缺陷**：多个CPU均拥有自身的缓存，并发场景下会引发数据可见性问题。

### 1.2.操作系统

- **优化点**：加入进程线程进行分时复用，更为合理地使用资源。
- **缺陷**：线程切换带来的原子操作问题，一个操作往往是由多条指令进行完成，而操作系统是以指令为单位进行执行就导致了一个操作极有可能不是原子操作，遂存在并发问题。

### 1.3.程序编译

- **优化点** ：单条指令分为取指、译码、执行、访存、写回五个流程，由于当前的CPU基本都是采用了流水线技术，部分流程所需要流程使用的设备资源不同，所以同一个CPU不同流水线且处于不同流程的指令可以实现准并行操作，进而提升CPU各部分资源利用率。说白了是类似于操作系统加入进程线程实现更细粒度管理进而实现准并行。
- **缺陷**：存在隐式因果关系的指令在重排后会使得结果与正常情况执行的结果不符。

## 2.Java并发问题解决方案

Java以内存模型规范了禁用缓存及编译优化，为开发人员提供了volatile、final、lock三大原语及Happend-Before原则控制并发问题。

### 2.1.volatile

    volatile关键字在JDK1.5保证了可见性，以volatile关键字修饰的变量表示读写数据不能使用CPU缓存而直接从内存进行读写操作。

### 2.2.final

    final关键字修饰的变量表示该变量生而不变，编译器可以尽管优化，不变也是保证了可见性。

### 2.3.lock

    lock原语用于保证原子性，lock原语不单单指Lock及其实现类，Java还提供了实现隐式锁的synchronized关键字保证原子性。

### 2.4.Happend-Before原则

    Happend-Before原则即前一个操作的结果对后面的操作是可见的。分为以下六项：

- 程序的顺序性规则
        
    在同一个线程中不会发生指令重排，保证了有序性。

- volatile规则
    
    对volatile修饰的变量的写操作的结果对读操作是可见的。

- 传递性
    
    若A操作 `Happends-Before` B操作，且B操作 `Happends-Before` C操作，那么A操作 `Happends-Before` C操作。

- 锁规则

    对一个锁的加锁操作 `Happends-Before` 锁的释放操作。

- 线程start()规则

    主线程A启动子线程B后，子线程B对自身启动前的操作结果是已知的。

- 线程join()规则

    主线程通过调用子线程join()方法来使主线程等待子线程结束后才继续执行，那么主线程对子线程完成执行前的操作结果对主线程都是可见的。

## 3.参考资料

- [处理器中的流水线技术](https://blog.csdn.net/m0_37608982/article/details/81865980)