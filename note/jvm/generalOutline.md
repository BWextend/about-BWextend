# 深入拆解JVM总纲

## 一、基础

### 1.1、Java的基本类型

### 1.2、JVM类加载过程

- 类加载流程
    1. 加载：找到对应类的字节流，并创建类
        - 类加载器
            1. 启动类加载器bootstrap class loader
            2. 扩展类加载器extension class loader
            3. 应用类加载器application class loader
        - 双亲委派机制
        - 自定义类加载器
        - 类加载器的命名空间
    2. 链接：将加载流程创建的类合并到虚拟机，使之能够运行
        1. 验证：验证加载的类是否符合JVM对于正常类的标准
        2. 准备：为加载类的静态字段分配内存
        3. 解析：将符号引用解析为实际引用
            - 符号引用？
    3. 初始化：为常量字段赋值
        - `<client>方法`？
        - 类的初始化触发情况
            - 当虚拟机启动时，初始化用户指定的主类
            - 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类
            - 当遇到调用静态方法的指令时，初始化该静态方法所在的类
            - 当遇到访问静态字段的指令时，初始化该静态字段所在的类
            - 子类的初始化会触发父类的初始化
            - 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化
            - 使用反射 API 对某个类进行反射调用时，初始化这个类
            - 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类
        - 单例延时加载：由于类的初始化只被执行一次，因此程序可以确保并发场景下实现线程安全的单例创建

### 1.3、JVM执行方法调用流程（上）

### 1.4、JVM执行方法调用流程（下）

### 1.5、JVM异常处理

### 1.6、JVM反射实现

### 1.7、Lambda表达式运行流程

### 1.8、JVM构建对象步骤

### 1.9、垃圾收集

### 1.10、JVM同步实现

### 1.11、Java内存模型

### 1.12、JVM安全点

## 二、高效实现

### 2.1、javac编译源码流程

### 2.2、注解解释器使用

### 2.3、即时编译触发

### 2.4、即时编译器与静态编译器的区别

### 2.5、即时编译器优化点

### 2.6、重复读写被优化的情况

### 2.7、循环代码被优化的情况

### 2.8、对象分配被优化的情况

### 2.9、方法调用被内联的情况

### 2.10、intrinsics

### 2.11、向量化计算

## 三、代码优化

### 3.1、JVM内置的编译/GC日志

### 3.2、使用JFR与JMC监控Java程序

### 3.3、使用MAT分析堆使用状况

### 3.4、使用JMH评估代码性能

### 3.5、Java代码与C++代码交互

### 3.6、使用JVMTI监听JVM事件

### 3.7、利用字节码为已有代码加料

### 3.8、利用Unsafe API绕开JVM控制

## 四、黑科技

### 4.1、Graal：用Java编译Java

### 4.2、Truffle：用Java编译其他语言

### 4.3、SubstrateVM：用Java编译虚拟机

### 4.4、Metropolis：Java-on-Java的展望